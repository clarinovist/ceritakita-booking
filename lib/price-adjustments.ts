
import { type Booking } from './storage-sqlite';
import { type BookingAddon, getAllAddons } from './addons';
import { safeNumber } from './type-utils';

export interface PriceAdjustmentInput {
    bookingId: string;
    addonId: string;
    quantity?: number;
    customPrice?: number; // For manual adjustments
    reason?: string;
}

/**
 * Add a price adjustment to an existing booking
 * Returns the new total price and updated addons list
 */
export async function addPriceAdjustment(
    currentBooking: Booking,
    adjustment: PriceAdjustmentInput
): Promise<{ newAddons: BookingAddon[], newTotalPrice: number }> {
    // Get all addons to find the specific one
    // Note: optimized implementation would fetch single addon, but getAllAddons is cached/fast enough for now
    const allAddons = getAllAddons();
    const addon = allAddons.find(a => a.id === adjustment.addonId);

    if (!addon) {
        throw new Error('Addon not found');
    }

    // Check if addon is applicable to this service category
    if (addon.applicable_categories && addon.applicable_categories.length > 0) {
        if (!addon.applicable_categories.includes(currentBooking.customer.category)) {
            throw new Error(`Addon '${addon.name}' is not applicable to service category '${currentBooking.customer.category}'`);
        }
    }

    // Determine price (use custom price if provided, otherwise use addon price)
    const price = adjustment.customPrice ?? addon.price;
    const quantity = adjustment.quantity ?? 1;

    // Get existing addons
    // Use spread to create a copy to avoid mutating original if needed
    const existingAddons = currentBooking.addons ? [...currentBooking.addons] : [];

    // Check if addon of this type already exists in the booking
    const existingAddonIndex = existingAddons.findIndex(a => a.addon_id === adjustment.addonId);

    let newAddons: BookingAddon[];
    if (existingAddonIndex >= 0) {
        // Update existing addon quantity
        newAddons = [...existingAddons];
        const existing = newAddons[existingAddonIndex];
        if (!existing) {
             throw new Error("Unexpected error: addon not found at index");
        }
        newAddons[existingAddonIndex] = {
            ...existing,
            quantity: existing.quantity + quantity
        };
    } else {
        // Add new addon
        newAddons = [
            ...existingAddons,
            {
                addon_id: adjustment.addonId,
                addon_name: addon.name,
                quantity,
                price_at_booking: price
            }
        ];
    }

    // Calculate new addons total
    const newAddonsTotal = newAddons.reduce((sum, a) =>
        sum + (safeNumber(a.price_at_booking) * safeNumber(a.quantity)), 0
    );

    const serviceBase = currentBooking.finance.service_base_price ?? 0;
    // If service_base_price is 0 (migrated data), we might need to rely on total_price minus old addons.
    // BUT for robustness, if we are recalculating, we should start from base.
    // If base is missing, we might have issues.
    // However, existing `update/route.ts` logic suggests `service_base_price` is reliable or we fallback.
    // Let's assume `serviceBase` is correct. If it's 0 and `total_price` > 0, it means it's an old record without breakdown.

    // Handling legacy data without breakdown:
    // If service_base_price is 0 but total_price is set, we might need to set service_base_price = total_price - existing_addons_total

    let basePrice = serviceBase;
    if (basePrice === 0 && currentBooking.finance.total_price > 0 && (!currentBooking.addons || currentBooking.addons.length === 0)) {
        // Very old booking with no addons and no breakdown
        basePrice = currentBooking.finance.total_price;
    }

    const baseDiscount = currentBooking.finance.base_discount ?? 0;
    const couponDiscount = currentBooking.finance.coupon_discount ?? 0;

    const newTotalPrice = Math.max(0, basePrice + newAddonsTotal - baseDiscount - couponDiscount);

    return { newAddons, newTotalPrice };
}

/**
 * Helper for common scenario: Add extra person
 */
export async function addExtraPerson(booking: Booking, count: number = 1) {
    // We need to look up the ID. Since we can't hardcode UUIDs generated by seed unless we know them.
    // Wait, the seed script checks by name.
    // AND I didn't hardcode UUIDs in seed script, I used crypto.randomUUID().
    // So I can't hardcode IDs here.
    // I need to look up addon by name or store fixed IDs in seed if possible.
    // Actually, looking up by name is risky if name changes.
    // Best practice: The seed script SHOULD have used fixed IDs if we want to reference them in code.
    // OR, we look them up dynamically here.

    // Let's fetch all addons and find by name for these helpers.
    const addons = getAllAddons();
    const extraPersonAddon = addons.find(a => a.name === 'Tambah Orang');

    if (!extraPersonAddon) throw new Error('Addon "Tambah Orang" not found');

    return addPriceAdjustment(booking, {
        bookingId: booking.id,
        addonId: extraPersonAddon.id,
        quantity: count,
        reason: `Tambah ${count} orang saat eksekusi`
    });
}

// Map defining which addon corresponds to which service transition
export type ServiceTransitionMap = Record<string, Record<string, string>>;

export const SERVICE_UPGRADE_MAP: ServiceTransitionMap = {
    'Prewedding Bronze': {
        'Prewedding Silver': 'Upgrade ke Prewedding Silver',
    },
    'Prewedding Silver': {
        'Prewedding Bronze': 'Downgrade ke Prewedding Bronze',
    },
    // Add more transitions here as needed
};

/**
 * Helper to find the addon name for a service upgrade/downgrade
 */
export function getServiceUpgradeAddonName(currentCategory: string, targetCategory: string): string | null {
    const transitions = SERVICE_UPGRADE_MAP[currentCategory];
    if (!transitions) return null;
    return transitions[targetCategory] || null;
}

/**
 * Helper for service upgrade
 */
export async function upgradeService(booking: Booking, targetService: string) {
    const currentCategory = booking.customer.category;
    const addonName = getServiceUpgradeAddonName(currentCategory, targetService);

    if (!addonName) {
        throw new Error(`Automatic upgrade path from ${currentCategory} to ${targetService} not defined`);
    }

    const addons = getAllAddons();
    const upgradeAddon = addons.find(a => a.name === addonName);

    if (!upgradeAddon) {
        throw new Error(`Addon "${addonName}" required for upgrade not found in database`);
    }

    return addPriceAdjustment(booking, {
        bookingId: booking.id,
        addonId: upgradeAddon.id,
        quantity: 1,
        reason: `Upgrade dari ${currentCategory} ke ${targetService}`
    });
}
